#!/usr/bin/env bash

# =============================================
# GLOBAL CONFIGURATION
# =============================================
readonly LOG_FILE="/var/log/user_creation.log"
readonly ALLOWED_KEYS="/home/dotfiles/allowed_keys"
readonly MAX_USERNAME_LENGTH=32
readonly DEFAULT_SHELL="/bin/zsh"
readonly REQUIRED_COMMANDS=("curl" "jq" "adduser" "usermod")

DOTFILES_ROOT="/usr/local/share/dotfiles-system"
source "${DOTFILES_ROOT}/system/scripts/logging.sh"

# =============================================
# UTILITY FUNCTIONS
# =============================================

# Validate command dependencies
check_dependencies() {
  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      error "Required command '$cmd' not found. Please install it first."
    fi
  done
}

# =============================================
# CORE FUNCTIONALITY
# =============================================

validate_username() {
  local username="$1"

  if [ -z "$username" ] || [ "${#username}" -gt "$MAX_USERNAME_LENGTH" ]; then
    error "Username must be 1-$MAX_USERNAME_LENGTH characters long."
  fi

  if ! [[ "$username" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
    error "Invalid username. Must start with a letter/underscore and contain only [a-z0-9_-]."
  fi

  if id -u "$username" >/dev/null 2>&1; then
    error "User '$username' already exists."
  fi
}

create_user_account() {
  local username="$1"

  info "Creating user account: $username"
  adduser --home "/home/$username" --shell "$DEFAULT_SHELL" --gecos "" --disabled-password "$username" ||
    error "Failed to create user '$username'"
}

setup_user_groups() {
    local username="$1"

    # Handle Minecraft group specially (check existence first)
    if getent group minecraft >/dev/null; then
        if confirm "Add user '$username' to minecraft group?"; then
            add_to_group "$username" "minecraft"
        fi
    else
        warn "minecraft group not found - skipping"
    fi

    # Prompt for additional groups
    while confirm "Would you like to add user '$username' to any other groups?"; do
        read -rp "Enter group name (or leave blank to finish): " group_name

        # Exit if blank input
        [ -z "$group_name" ] && break

        if getent group "$group_name" >/dev/null; then
            add_to_group "$username" "$group_name"
        else
            warn "Group '$group_name' does not exist (skipping)"
        fi
    done
}

add_to_group() {
    local username="$1"
    local group="$2"

    if usermod -aG "$group" "$username"; then
        info "Successfully added $username to $group group"
        return 0
    else
        warn "Failed to add $username to $group group"
        return 1
    fi
}

#!/usr/bin/env bash

# Debugging: Uncomment to see script execution flow
# set -x

import_github_keys() {
  local github_username="$1"
  local temp_file
  temp_file=$(mktemp "/tmp/github_keys_XXXXXX") || {
    error "Failed to create temporary file"
    return 1
  }

  info "Fetching SSH keys from GitHub for user: $github_username"

  # Check GitHub API rate limits first
  local rate_limit
  rate_limit=$(curl -s "https://api.github.com/rate_limit") || {
    error "Failed to check GitHub rate limits"
    rm -f "$temp_file"
    return 1
  }

  local remaining
  remaining=$(echo "$rate_limit" | jq -r '.resources.core.remaining')
  if (( remaining < 1 )); then
    error "GitHub API rate limit exceeded (remaining: $remaining)"
    rm -f "$temp_file"
    return 1
  fi

  # Fetch keys with timeout and proper error handling
  local response
  response=$(curl -s --max-time 10 \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/users/$github_username/keys") || {
    error "Failed to fetch keys from GitHub (curl error)"
    rm -f "$temp_file"
    return 1
  }

  # Check for empty response
  if [[ -z "$response" ]]; then
    error "Received empty response from GitHub API"
    rm -f "$temp_file"
    return 1
  fi

  # Check for API errors
  if [[ "$response" == *"Not Found"* ]]; then
    error "GitHub user '$github_username' not found"
    rm -f "$temp_file"
    return 1
  fi

  if [[ "$response" == *"rate limit exceeded"* ]]; then
    error "GitHub API rate limit exceeded"
    rm -f "$temp_file"
    return 1
  fi

  # Parse keys and handle jq errors
  if ! echo "$response" | jq -r '.[].key' > "$temp_file" 2>/dev/null; then
    error "Failed to parse GitHub API response"
    rm -f "$temp_file"
    return 1
  fi

  # Verify we got actual keys
  if [[ ! -s "$temp_file" ]]; then
    error "No SSH keys found for GitHub user '$github_username'"
    rm -f "$temp_file"
    return 1
  fi

  info "Successfully fetched $(wc -l < "$temp_file") SSH keys"
  echo "$temp_file"
}

setup_ssh_access() {
  local username="$1"
  local key_source="$2"
  local key_source_value="$3"
  local user_home="/home/$username"
  local user_ssh_dir="$user_home/.ssh"

  info "Setting up SSH access for $username"

  # Create .ssh directory with proper permissions
  mkdir -p "$user_ssh_dir" || {
    error "Failed to create .ssh directory"
    return 1
  }

  case "$key_source" in
    "github")
      info "Attempting to import keys from GitHub user: $key_source_value"

      local key_file
      key_file=$(import_github_keys "$key_source_value") || {
        error "Failed to import GitHub keys"
        return 1
      }

      # Verify the temp file exists and contains keys
      if [[ ! -f "$key_file" || ! -r "$key_file" ]]; then
        error "Temporary key file problem (exists: $([[ -f "$key_file" ]] && echo "yes" || echo "no"), readable: $([[ -r "$key_file" ]] && echo "yes" || echo "no"))"
        [[ -f "$key_file" ]] && rm -f "$key_file"
        return 1
      fi

      # Debug: Show the keys we're about to add
      debug "Keys to be added:"
      debug "$(cat "$key_file")"

      # Create authorized_keys if it doesn't exist
      touch "$user_ssh_dir/authorized_keys" || {
        rm -f "$key_file"
        error "Failed to create authorized_keys file"
        return 1
      }

      # Add header to identify these keys
      echo "# GitHub keys for $key_source_value" >> "$user_ssh_dir/authorized_keys" || {
        rm -f "$key_file"
        error "Failed to write to authorized_keys"
        return 1
      }

      # Append new keys
      cat "$key_file" >> "$user_ssh_dir/authorized_keys" || {
        rm -f "$key_file"
        error "Failed to append keys to authorized_keys"
        return 1
      }

      # Clean up
      rm -f "$key_file"

      info "Successfully imported GitHub SSH keys"
      ;;

    "local")
      [[ ! -f "$ALLOWED_KEYS" ]] && {
        error "SSH keys file not found at $ALLOWED_KEYS"
        return 1
      }
      cp "$ALLOWED_KEYS" "$user_ssh_dir/authorized_keys" || {
        error "Failed to copy SSH keys"
        return 1
      }
      ;;

    *)
      error "Invalid SSH key source specified: $key_source"
      return 1
      ;;
  esac

  # Set proper permissions
  chown -R "$username:$username" "$user_ssh_dir" || {
    error "Failed to set .ssh ownership"
    return 1
  }
  chmod 700 "$user_ssh_dir" || {
    error "Failed to set .ssh permissions"
    return 1
  }
  chmod 600 "$user_ssh_dir/authorized_keys" || {
    error "Failed to set authorized_keys permissions"
    return 1
  }

  # Final verification
  [[ -f "$user_ssh_dir/authorized_keys" ]] || {
    error "authorized_keys file missing after setup"
    return 1
  }

  debug "SSH setup complete. Contents of authorized_keys:"
  debug "$(cat "$user_ssh_dir/authorized_keys")"

  return 0
}

secure_home_directory() {
  local username="$1"
  local user_home="/home/$username"

  info "Securing home directory permissions"
  chmod 750 "$user_home" || warn "Failed to set home directory permissions"
  chown "$username:$username" "$user_home" || warn "Failed to set home directory ownership"
}

display_summary() {
  local username="$1"
  local key_source="$2"
  local github_user="$3"

  success "User creation completed: $username"
  cat <<EOF
âœ… User '$username' created successfully with:
   - Default shell: $DEFAULT_SHELL
   - Sudo privileges
   - SSH keys imported from: ${key_source}${github_user:+ ($github_user)}
EOF

  if getent group minecraft >/dev/null && id -nG "$username" | grep -qw minecraft; then
    echo "   - Added to minecraft group"
  fi
}

# =============================================
# MAIN FLOW
# =============================================

parse_arguments() {
  local username=""
  local github_user=""
  local key_source="local"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --github)
      [ -z "$2" ] && error "--github requires a GitHub username"
      github_user="$2"
      key_source="github"
      shift 2
      ;;
    --help | -h)
      show_usage
      ;;
    -*)
      error "Unknown option $1"
      ;;
    *)
      [ -z "$username" ] && username="$1" || error "Too many arguments"
      shift
      ;;
    esac
  done

  [ -z "$username" ] && read -rp "Enter the new username: " username

  echo "$username" "$key_source" "$github_user"
}

show_usage() {
  cat <<EOF
Usage: $0 [username] [--github GITHUB_USERNAME]

Options:
  username              The username to create (will prompt if not provided)
  --github USERNAME     Import SSH keys from GitHub user's account
EOF
  exit 0
}

main() {
  # Initial checks
  [ "$(id -u)" -ne 0 ] && error "This script must be run as root"
  check_dependencies

  # Parse arguments and get configuration
  read -r username key_source github_user <<<"$(parse_arguments "$@")"

  # Validate input
  validate_username "$username"

  # User creation flow
  create_user_account "$username"
    setup_user_groups "$username"
  if confirm "Make user '$username' a sudo user?"; then
    info "Adding $username to sudo group"
    usermod -aG sudo "$username" ||
      error "Failed to add '$username' to sudo group"
  fi
  setup_ssh_access "$username" "$key_source" "$github_user"
  secure_home_directory "$username"

  # Final output
  display_summary "$username" "$key_source" "$github_user"
}

main "$@"
