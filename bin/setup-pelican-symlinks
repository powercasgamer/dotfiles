#!/usr/bin/env bash
# pelican-symlinks - Advanced symlink management with name change detection

# Configuration
VOLUMES_DIR="/var/lib/pelican/volumes"
TARGET_DIR="/home/servers"
LOG_FILE="/var/log/pelican-symlinks.log"
DRY_RUN=false

# Color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Initialize
declare -A valid_symlinks
mkdir -p "$TARGET_DIR"

# Enhanced logging
log() {
    local level="$1"
    local message="$2"

    case "$level" in
        INFO) color="$GREEN" ;;
        WARN) color="$YELLOW" ;;
        ERROR) color="$RED" ;;
        *) color="$NC" ;;
    esac

    echo -e "${color}$(date '+%Y-%m-%d %H:%M:%S') - [$level] $message${NC}" | tee -a "$LOG_FILE"
}

# Verify symlink points to correct UUID
validate_symlink() {
    local symlink="$1"
    local expected_uuid="$2"

    if [[ ! -L "$symlink" ]]; then
        log WARN "Not a symlink: $symlink"
        return 1
    fi

    local target=$(readlink -f "$symlink")
    local actual_uuid=$(basename "$target")

    [[ "$actual_uuid" == "$expected_uuid" ]]
}

# Clean up orphaned symlinks
clean_orphans() {
    log INFO "Checking for orphaned symlinks..."

    while IFS= read -r -d '' symlink; do
        local name=$(basename "$symlink")

        if [[ ! -v valid_symlinks["$name"] ]]; then
            log WARN "Would remove orphaned symlink: $name"
            if [[ "$DRY_RUN" == false ]]; then
                rm -f "$symlink"
                log INFO "Removed orphaned symlink: $name"
            fi
        fi
    done < <(find "$TARGET_DIR" -maxdepth 1 -type l -print0)
}

# Main processing
process_servers() {
    log INFO "Starting server symlink processing"
    [[ "$DRY_RUN" == true ]] && log WARN "DRY RUN MODE - No changes will be made"

    # Process all servers
    while IFS= read -r -d '' name_file; do
        local uuid=$(basename "$(dirname "$name_file")")
        local server_name=$(tr -d '[:space:]' < "$name_file")
        local symlink_path="$TARGET_DIR/$server_name"

        if [[ -z "$server_name" ]]; then
            log WARN "Empty server name in $uuid"
            continue
        fi

        # Track valid server names
        valid_symlinks["$server_name"]=1

        # Check existing symlink
        if [[ -L "$symlink_path" ]]; then
            if validate_symlink "$symlink_path" "$uuid"; then
                log INFO "Valid symlink exists: $server_name → $uuid"
                continue
            else
                log WARN "Name change detected for $uuid (old symlink exists)"
                if [[ "$DRY_RUN" == false ]]; then
                    rm -f "$symlink_path"
                    log INFO "Removed outdated symlink: $server_name"
                fi
            fi
        fi

        log INFO "Would create symlink: $server_name → $uuid"
        if [[ "$DRY_RUN" == false ]]; then
            ln -sfn "$(dirname "$name_file")" "$symlink_path"
            log INFO "Created/updated symlink: $server_name → $uuid"
        fi
    done < <(find "$VOLUMES_DIR" -type f -name 'server-name' -print0)

    clean_orphans
    log INFO "Processing complete"
}

# Argument parsing
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--dry-run) DRY_RUN=true; shift ;;
            -h|--help) show_help; exit 0 ;;
            *) log ERROR "Invalid argument: $1"; show_help; exit 1 ;;
        esac
    done
}

show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo "Manage Pelican server symlinks with name change detection"
    echo ""
    echo "Options:"
    echo "  -d, --dry-run    Simulation mode (no changes made)"
    echo "  -h, --help       Show this help message"
}

# Main execution
main() {
    parse_args "$@"

    # Check Pelican installation
    if [[ ! -d "/var/www/pelican" ]]; then
        log ERROR "Pelican root directory not found at /var/www/pelican"
        exit 1
    fi

    # Check Pelican artisan command
    if [[ ! -f "/var/www/pelican/artisan" ]]; then
        log ERROR "Pelican artisan command not found - is Pelican properly installed?"
        exit 1
    fi

    [[ ! -d "$VOLUMES_DIR" ]] && { log ERROR "Volumes directory missing: $VOLUMES_DIR"; exit 1; }
    mkdir -p "$TARGET_DIR" || { log ERROR "Cannot create target directory"; exit 1; }

    process_servers
}

main "$@"